@using Plugin.Maui.OCR
@using System.Text.Json
@using Microsoft.Maui.Storage
@using System.IO
@using MauiApp2.Models
@using MauiApp2.Service
@* @using SkiaSharp; *@
@inject NavigationManager Navigation
@inject ImageService ImageService

@if (IsVisible)
{
    <div class="modal fade show d-block" tabindex="-1" role="dialog" style="background-color: rgba(0, 0, 0, 0.5);">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">@Title</h5>
                    <button type="button" class="btn-close" @onclick="CloseModal"></button>
                </div>
                <div class="modal-body">
                    <textarea class="form-control" rows="4" placeholder="Extracted Text" @bind="Image.ImgDataExtractedText" />
                    <div class="mt-3 d-flex gap-2">
                        <button class="btn btn-primary" @onclick="CaptureAndExtractText">📸 Click</button>
                        <button class="btn btn-success" @onclick="Upload">⬆️ Upload</button>
                        <button class="btn btn-secondary" @onclick="CloseModal">Cancel</button>
                    </div>

                    @if (!string.IsNullOrEmpty(Image.ImgDataImg))
                    {
                        <div class="mt-4 position-relative" style="max-width: 100%; width: 350px;">
                            <img src="@Image.ImgDataImg" class="img-fluid rounded shadow" />
                            <div class="position-absolute bottom-0 start-0 text-white w-100 p-2" style="background: rgba(0,0,0,0.5); font-size: 0.9rem;">
                                <div>📍 <strong>@Image.ImgDataExtractedText</strong></div>
                               @*  <div>⏰ @Imagdto.ImgDataTimedate?.ToString("dd-MMM-yyyy HH:mm:ss")</div> *@
                                @if (!string.IsNullOrEmpty(Image.ImgDataLocation))
                                {
                                    <div>🏠 <span>@Image.ImgDataLocation</span></div>
                                }
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public ImageModel Image { get; set; } = new ImageModel();
    
    [Parameter] public string Title { get; set; } = "Add Image";
    [Parameter] public string ButtonText { get; set; } = "Add";
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnSubmit { get; set; }
    private bool isLoading = true;
    private string? errorMessage;

    // Pagination
    private int currentPage = 1;
    private int totalPages = 1;
    private int pageSize = 10;

 
    // public static class ImageCompressor
    // {
    //     public static byte[] CompressImage(byte[] inputBytes, int maxSizeKb = 10, int initialQuality = 50)
    //     {
    //         using var inputStream = new SKMemoryStream(inputBytes);
    //         using var codec = SKCodec.Create(inputStream);
    //         var bitmap = SKBitmap.Decode(codec);

    //         if (bitmap == null)
    //             throw new Exception("Failed to decode image.");

    //         using var image = SKImage.FromBitmap(bitmap);

    //         int quality = initialQuality;
    //         byte[] compressedBytes;

    //         do
    //         {
    //             using var data = image.Encode(SKEncodedImageFormat.Jpeg, quality);
    //             compressedBytes = data.ToArray();
    //             quality -= 5;

    //         } while (compressedBytes.Length > maxSizeKb * 1024 && quality > 5);

    //         return compressedBytes;
    //     }

    // }


    private async Task<string> GetAddressFromCoordinates(double lat, double lng)
    {
        try
        {
            using var httpClient = new HttpClient();
            var url = $"https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat={lat}&lon={lng}";
            httpClient.DefaultRequestHeaders.UserAgent.TryParseAdd("request");

            var response = await httpClient.GetAsync(url);
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                var result = JsonDocument.Parse(json);
                if (result.RootElement.TryGetProperty("display_name", out var displayName))
                {
                    return displayName.GetString();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Reverse geocode failed: {ex.Message}");
        }
        return "Address not found";
    }

    private async Task CaptureAndExtractText()
    {
        try
        {
            var cameraStatus = await Permissions.CheckStatusAsync<Permissions.Camera>();
            if (cameraStatus != PermissionStatus.Granted)
                cameraStatus = await Permissions.RequestAsync<Permissions.Camera>();

            if (cameraStatus != PermissionStatus.Granted)
            {
                Image.ImgDataExtractedText = "Camera permission denied.";
                return;
            }

            var photo = await MediaPicker.CapturePhotoAsync();
            if (photo != null)
            {
                using var stream = await photo.OpenReadAsync();
                using var ms = new MemoryStream();
                await stream.CopyToAsync(ms);
                var imageBytes = ms.ToArray();
  // 🔽 Compress to under 10KB
    // var compressedBytes = ImageCompressor.CompressImage(imageBytes, 10);
                Image.ImgDataImg = $"data:image/jpeg;base64,{Convert.ToBase64String(imageBytes)}";

                var ocrResult = await OcrPlugin.Default.RecognizeTextAsync(imageBytes);
                Image.ImgDataExtractedText = ocrResult.Success ? ocrResult.AllText : "OCR failed.";

                var locationStatus = await Permissions.CheckStatusAsync<Permissions.LocationWhenInUse>();
                if (locationStatus != PermissionStatus.Granted)
                    locationStatus = await Permissions.RequestAsync<Permissions.LocationWhenInUse>();

                if (locationStatus == PermissionStatus.Granted)
                {
                    var location = await Geolocation.GetLastKnownLocationAsync() ?? await Geolocation.GetLocationAsync(new GeolocationRequest
                    {
                        DesiredAccuracy = GeolocationAccuracy.High,
                        Timeout = TimeSpan.FromSeconds(10)
                    });

                    if (location != null)
                    {
                        Image.Latitude = location.Latitude;
                        Image.Longitude = location.Longitude;
                        Image.ImgDataLocation = await GetAddressFromCoordinates(location.Latitude, location.Longitude);
                    }
                }

                Image.ImgDataTimedate = DateTime.Now;
            }
        }
        catch (Exception ex)
        {
            Image.ImgDataExtractedText = $"Error: {ex.Message}";
        }
    }

    private async Task Upload()
    {
        try
        {
            if (string.IsNullOrEmpty(Image.ImgDataImg) || string.IsNullOrEmpty(Image.ImgDataExtractedText))
            {
                Image.ImgDataExtractedText += "\n⚠️ Please take a photo and extract text before uploading.";
                return;
            }

            await ImageService.AddImageAsync(Image.ImgDataImg, Image.ImgDataExtractedText, Image.ImgDataLocation, Image.ImgDataUserUploaded, Image.ImgDataCreateUid, Image.ImgDataEditedUid); // ✅ Use bound parameter directly
            // await OnSubmit.InvokeAsync(); // Notify parent to refresh list
            await CloseModal();
            Navigation.NavigateTo("/Image", true);
        }
        catch (Exception ex)
        {
            Image.ImgDataExtractedText += $"\n❌ Upload failed: {ex.Message}";
        }
    }

    // private async Task LoadDetailsImage()
    // {
    //     isLoading = true;
    //     errorMessage = null;

    //     try
    //     {
    //         var response = await ImageService.GetImaggeAsync();
    //         // imgmodel = response.data;
    //         // totalPages = (int)Math.Ceiling((double)imgmodel.Count / pageSize);
    //     }
    //     catch (Exception ex)
    //     {
    //         errorMessage = $"Error loading images: {ex.Message}";
    //     }
    //     finally
    //     {
    //         isLoading = false;
    //     }
    // }

    private async Task CloseModal() => await OnClose.InvokeAsync();
}
